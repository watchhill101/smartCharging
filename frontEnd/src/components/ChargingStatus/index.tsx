import React, { useState, useEffect, useCallback, useRef } from 'react';
import { View, Text, Canvas } from '@tarojs/components';
import Taro from '@tarojs/taro';
import {
  Button as NutButton,
  Progress,
  Card,
  Divider,
  Tag,
  Toast,
  Dialog,
  Loading,
  Icon
} from '@nutui/nutui-react-taro';
import './index.scss';

export interface ChargingStatusData {
  sessionId: string;
  pileId: string;
  pileName: string;
  pileNumber: string;
  
  // ÂÖÖÁîµÁä∂ÊÄÅ
  status: 'preparing' | 'charging' | 'suspended' | 'finishing' | 'completed' | 'faulted';
  
  // Êó∂Èó¥‰ø°ÊÅØ
  startTime: string;
  currentTime: string;
  estimatedEndTime?: string;
  duration: number; // Áßí
  
  // ÁîµÈáè‰ø°ÊÅØ
  currentPower: number; // kW
  maxPower: number; // kW
  energyDelivered: number; // kWh
  targetEnergy?: number; // kWh
  
  // ÁîµÊ∞îÂèÇÊï∞
  voltage: number; // V
  current: number; // A
  temperature: number; // ¬∞C
  
  // Ë¥πÁî®‰ø°ÊÅØ
  currentCost: number; // ÂÖÉ
  pricePerKwh: number; // ÂÖÉ/kWh
  
  // ËΩ¶ËæÜ‰ø°ÊÅØ
  batteryLevel?: number; // %
  batteryCapacity?: number; // kWh
  
  // È¢Ñ‰º∞‰ø°ÊÅØ
  estimatedCost?: number; // ÂÖÉ
  estimatedDuration?: number; // Áßí
  chargingEfficiency?: number; // %
}

export interface ChargingStatusProps {
  sessionId: string;
  data?: ChargingStatusData;
  loading?: boolean;
  
  // ‰∫ã‰ª∂ÂõûË∞É
  onStopCharging?: (sessionId: string) => void;
  onPauseCharging?: (sessionId: string) => void;
  onResumeCharging?: (sessionId: string) => void;
  onRefresh?: () => void;
  onNavigateToStation?: (pileId: string) => void;
  
  // ÊòæÁ§∫ÈÖçÁΩÆ
  showControls?: boolean;
  showDetails?: boolean;
  showChart?: boolean;
  autoRefresh?: boolean;
  refreshInterval?: number;
  
  className?: string;
}

interface StatusState {
  showStopDialog: boolean;
  showDetailsDialog: boolean;
  showChartDialog: boolean;
  chartType: 'power' | 'energy' | 'cost';
  powerHistory: Array<{ time: string; power: number }>;
  energyHistory: Array<{ time: string; energy: number }>;
  costHistory: Array<{ time: string; cost: number }>;
}

const ChargingStatus: React.FC<ChargingStatusProps> = ({
  sessionId,
  data,
  loading = false,
  onStopCharging,
  onPauseCharging,
  onResumeCharging,
  onRefresh,
  onNavigateToStation,
  showControls = true,
  showDetails = true,
  showChart = true,
  autoRefresh = true,
  refreshInterval = 5000,
  className = ''
}) => {
  const [state, setState] = useState<StatusState>({
    showStopDialog: false,
    showDetailsDialog: false,
    showChartDialog: false,
    chartType: 'power',
    powerHistory: [],
    energyHistory: [],
    costHistory: []
  });

  const refreshTimerRef = useRef<NodeJS.Timeout | null>(null);
  const canvasRef = useRef<any>(null);

  // Áä∂ÊÄÅÊò†Â∞Ñ
  const statusMap = {
    preparing: { label: 'ÂáÜÂ§á‰∏≠', color: '#faad14', icon: '‚è≥' },
    charging: { label: 'ÂÖÖÁîµ‰∏≠', color: '#52c41a', icon: '‚ö°' },
    suspended: { label: 'Â∑≤ÊöÇÂÅú', color: '#1890ff', icon: '‚è∏Ô∏è' },
    finishing: { label: 'ÁªìÊùü‰∏≠', color: '#722ed1', icon: 'üîÑ' },
    completed: { label: 'Â∑≤ÂÆåÊàê', color: '#13c2c2', icon: '‚úÖ' },
    faulted: { label: 'ÊïÖÈöú', color: '#ff4d4f', icon: '‚ùå' }
  };

  // Ëá™Âä®Âà∑Êñ∞
  useEffect(() => {
    if (autoRefresh && data?.status === 'charging') {
      refreshTimerRef.current = setInterval(() => {
        onRefresh?.();
      }, refreshInterval);
    }

    return () => {
      if (refreshTimerRef.current) {
        clearInterval(refreshTimerRef.current);
      }
    };
  }, [autoRefresh, data?.status, refreshInterval, onRefresh]);

  // Êõ¥Êñ∞ÂéÜÂè≤Êï∞ÊçÆ
  useEffect(() => {
    if (data) {
      const currentTime = new Date().toLocaleTimeString();
      
      setState(prev => ({
        ...prev,
        powerHistory: [
          ...prev.powerHistory.slice(-19), // ‰øùÁïôÊúÄËøë20‰∏™Êï∞ÊçÆÁÇπ
          { time: currentTime, power: data.currentPower }
        ],
        energyHistory: [
          ...prev.energyHistory.slice(-19),
          { time: currentTime, energy: data.energyDelivered }
        ],
        costHistory: [
          ...prev.costHistory.slice(-19),
          { time: currentTime, cost: data.currentCost }
        ]
      }));
    }
  }, [data]);

  // Ê†ºÂºèÂåñÊó∂Èó¥
  const formatDuration = useCallback((seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
  }, []);

  // Ê†ºÂºèÂåñÊó∂Èó¥ÔºàÈ¢Ñ‰º∞Ôºâ
  const formatEstimatedTime = useCallback((seconds?: number): string => {
    if (!seconds) return '--';
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    if (hours > 0) {
      return `Á∫¶${hours}Â∞èÊó∂${minutes}ÂàÜÈíü`;
    } else {
      return `Á∫¶${minutes}ÂàÜÈíü`;
    }
  }, []);

  // ËÆ°ÁÆóÂÖÖÁîµËøõÂ∫¶
  const getChargingProgress = useCallback((): number => {
    if (!data) return 0;
    
    if (data.targetEnergy && data.targetEnergy > 0) {
      return Math.min((data.energyDelivered / data.targetEnergy) * 100, 100);
    }
    
    if (data.batteryLevel && data.batteryLevel > 0) {
      return data.batteryLevel;
    }
    
    // Ê†πÊçÆÊó∂Èó¥ËøõÂ∫¶‰º∞ÁÆó
    if (data.estimatedDuration && data.duration > 0) {
      return Math.min((data.duration / data.estimatedDuration) * 100, 100);
    }
    
    return 0;
  }, [data]);

  // Â§ÑÁêÜÂÅúÊ≠¢ÂÖÖÁîµ
  const handleStopCharging = useCallback(() => {
    setState(prev => ({ ...prev, showStopDialog: true }));
  }, []);

  const confirmStopCharging = useCallback(() => {
    onStopCharging?.(sessionId);
    setState(prev => ({ ...prev, showStopDialog: false }));
    
    Toast.show({
      content: 'Ê≠£Âú®ÂÅúÊ≠¢ÂÖÖÁîµ...',
      type: 'loading',
      duration: 2000
    });
  }, [sessionId, onStopCharging]);

  // Â§ÑÁêÜÊöÇÂÅú/ÊÅ¢Â§çÂÖÖÁîµ
  const handlePauseResume = useCallback(() => {
    if (data?.status === 'charging') {
      onPauseCharging?.(sessionId);
      Toast.show({
        content: 'Ê≠£Âú®ÊöÇÂÅúÂÖÖÁîµ...',
        type: 'loading',
        duration: 2000
      });
    } else if (data?.status === 'suspended') {
      onResumeCharging?.(sessionId);
      Toast.show({
        content: 'Ê≠£Âú®ÊÅ¢Â§çÂÖÖÁîµ...',
        type: 'loading',
        duration: 2000
      });
    }
  }, [data?.status, sessionId, onPauseCharging, onResumeCharging]);

  // Â§ÑÁêÜÂØºËà™Âà∞ÂÖÖÁîµÁ´ô
  const handleNavigateToStation = useCallback(() => {
    if (data?.pileId) {
      onNavigateToStation?.(data.pileId);
    }
  }, [data?.pileId, onNavigateToStation]);

  // ÊòæÁ§∫ËØ¶ÊÉÖ
  const showDetails = useCallback(() => {
    setState(prev => ({ ...prev, showDetailsDialog: true }));
  }, []);

  // ÊòæÁ§∫ÂõæË°®
  const showChart = useCallback((chartType: 'power' | 'energy' | 'cost') => {
    setState(prev => ({ 
      ...prev, 
      showChartDialog: true,
      chartType 
    }));
  }, []);

  // ÁªòÂà∂ÂõæË°®
  const drawChart = useCallback(() => {
    if (!canvasRef.current || !data) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = 300;
    const height = 200;
    
    // Ê∏ÖÁ©∫ÁîªÂ∏É
    ctx.clearRect(0, 0, width, height);
    
    // Ëé∑ÂèñÊï∞ÊçÆ
    let chartData: Array<{ time: string; value: number }> = [];
    let label = '';
    let unit = '';
    let color = '#1890ff';
    
    switch (state.chartType) {
      case 'power':
        chartData = state.powerHistory.map(item => ({ time: item.time, value: item.power }));
        label = 'ÂäüÁéá';
        unit = 'kW';
        color = '#52c41a';
        break;
      case 'energy':
        chartData = state.energyHistory.map(item => ({ time: item.time, value: item.energy }));
        label = 'ÁîµÈáè';
        unit = 'kWh';
        color = '#1890ff';
        break;
      case 'cost':
        chartData = state.costHistory.map(item => ({ time: item.time, value: item.cost }));
        label = 'Ë¥πÁî®';
        unit = 'ÂÖÉ';
        color = '#faad14';
        break;
    }
    
    if (chartData.length < 2) return;
    
    // ËÆ°ÁÆóÊï∞ÊçÆËåÉÂõ¥
    const values = chartData.map(item => item.value);
    const minValue = Math.min(...values);
    const maxValue = Math.max(...values);
    const valueRange = maxValue - minValue || 1;
    
    // ÁªòÂà∂ÂùêÊ†áËΩ¥
    ctx.strokeStyle = '#d9d9d9';
    ctx.lineWidth = 1;
    
    // YËΩ¥
    ctx.beginPath();
    ctx.moveTo(40, 20);
    ctx.lineTo(40, height - 40);
    ctx.stroke();
    
    // XËΩ¥
    ctx.beginPath();
    ctx.moveTo(40, height - 40);
    ctx.lineTo(width - 20, height - 40);
    ctx.stroke();
    
    // ÁªòÂà∂Êï∞ÊçÆÁ∫ø
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    chartData.forEach((point, index) => {
      const x = 40 + (index / (chartData.length - 1)) * (width - 60);
      const y = height - 40 - ((point.value - minValue) / valueRange) * (height - 60);
      
      if (index === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    
    ctx.stroke();
    
    // ÁªòÂà∂Êï∞ÊçÆÁÇπ
    ctx.fillStyle = color;
    chartData.forEach((point, index) => {
      const x = 40 + (index / (chartData.length - 1)) * (width - 60);
      const y = height - 40 - ((point.value - minValue) / valueRange) * (height - 60);
      
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, 2 * Math.PI);
      ctx.fill();
    });
    
    // ÁªòÂà∂Ê†áÁ≠æ
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${label} (${unit})`, width / 2, 15);
    
    // ÁªòÂà∂Êï∞ÂÄºÊ†áÁ≠æ
    ctx.textAlign = 'right';
    ctx.fillText(maxValue.toFixed(1), 35, 25);
    ctx.fillText(minValue.toFixed(1), 35, height - 45);
    
  }, [data, state.chartType, state.powerHistory, state.energyHistory, state.costHistory]);

  // ÂõæË°®ÊòæÁ§∫Êó∂ÁªòÂà∂
  useEffect(() => {
    if (state.showChartDialog) {
      setTimeout(drawChart, 100);
    }
  }, [state.showChartDialog, drawChart]);

  if (loading) {
    return (
      <View className={`charging-status loading ${className}`}>
        <Loading type="spinner" />
        <Text className="loading-text">Âä†ËΩΩÂÖÖÁîµÁä∂ÊÄÅ...</Text>
      </View>
    );
  }

  if (!data) {
    return (
      <View className={`charging-status error ${className}`}>
        <Text className="error-text">ÂÖÖÁîµÁä∂ÊÄÅÊï∞ÊçÆ‰∏çÂèØÁî®</Text>
        <NutButton type="primary" onClick={onRefresh}>
          ÈáçÊñ∞Âä†ËΩΩ
        </NutButton>
      </View>
    );
  }

  const statusInfo = statusMap[data.status];
  const progress = getChargingProgress();

  return (
    <View className={`charging-status ${className}`}>
      {/* Áä∂ÊÄÅÂç°Áâá */}
      <Card className="status-card">
        <View className="status-header">
          <View className="status-info">
            <View className="status-badge" style={{ backgroundColor: statusInfo.color }}>
              <Text className="status-icon">{statusInfo.icon}</Text>
              <Text className="status-text">{statusInfo.label}</Text>
            </View>
            <Text className="pile-info">{data.pileName} - {data.pileNumber}</Text>
          </View>
          
          <View className="status-actions">
            <NutButton
              type="default"
              size="mini"
              onClick={onRefresh}
              className="refresh-btn"
            >
              üîÑ
            </NutButton>
            
            <NutButton
              type="default"
              size="mini"
              onClick={handleNavigateToStation}
              className="navigate-btn"
            >
              üìç
            </NutButton>
          </View>
        </View>

        {/* ÂÖÖÁîµËøõÂ∫¶ */}
        <View className="charging-progress">
          <View className="progress-header">
            <Text className="progress-label">ÂÖÖÁîµËøõÂ∫¶</Text>
            <Text className="progress-value">{progress.toFixed(1)}%</Text>
          </View>
          
          <Progress
            percentage={progress}
            strokeColor={statusInfo.color}
            showText={false}
            className="progress-bar"
          />
          
          {data.targetEnergy && (
            <Text className="progress-detail">
              {data.energyDelivered.toFixed(1)} / {data.targetEnergy.toFixed(1)} kWh
            </Text>
          )}
        </View>

        {/* ÂÖ≥ÈîÆÊåáÊ†á */}
        <View className="key-metrics">
          <View className="metric-item">
            <Text className="metric-label">ÂΩìÂâçÂäüÁéá</Text>
            <Text className="metric-value">{data.currentPower.toFixed(1)} kW</Text>
          </View>
          
          <View className="metric-item">
            <Text className="metric-label">Â∑≤ÂÖÖÁîµÈáè</Text>
            <Text className="metric-value">{data.energyDelivered.toFixed(1)} kWh</Text>
          </View>
          
          <View className="metric-item">
            <Text className="metric-label">ÂÖÖÁîµÊó∂Èïø</Text>
            <Text className="metric-value">{formatDuration(data.duration)}</Text>
          </View>
          
          <View className="metric-item">
            <Text className="metric-label">ÂΩìÂâçË¥πÁî®</Text>
            <Text className="metric-value">¬•{data.currentCost.toFixed(2)}</Text>
          </View>
        </View>

        {/* È¢Ñ‰º∞‰ø°ÊÅØ */}
        {(data.estimatedEndTime || data.estimatedCost || data.estimatedDuration) && (
          <>
            <Divider />
            <View className="estimated-info">
              <Text className="section-title">È¢Ñ‰º∞‰ø°ÊÅØ</Text>
              
              <View className="estimated-items">
                {data.estimatedDuration && (
                  <View className="estimated-item">
                    <Text className="estimated-label">È¢ÑËÆ°Ââ©‰ΩôÊó∂Èó¥</Text>
                    <Text className="estimated-value">
                      {formatEstimatedTime(data.estimatedDuration - data.duration)}
                    </Text>
                  </View>
                )}
                
                {data.estimatedCost && (
                  <View className="estimated-item">
                    <Text className="estimated-label">È¢ÑËÆ°ÊÄªË¥πÁî®</Text>
                    <Text className="estimated-value">¬•{data.estimatedCost.toFixed(2)}</Text>
                  </View>
                )}
                
                {data.estimatedEndTime && (
                  <View className="estimated-item">
                    <Text className="estimated-label">È¢ÑËÆ°ÂÆåÊàêÊó∂Èó¥</Text>
                    <Text className="estimated-value">
                      {new Date(data.estimatedEndTime).toLocaleTimeString()}
                    </Text>
                  </View>
                )}
              </View>
            </View>
          </>
        )}
      </Card>

      {/* ËØ¶ÁªÜ‰ø°ÊÅØÊåâÈíÆ */}
      {showDetails && (
        <View className="detail-buttons">
          <NutButton
            type="default"
            onClick={showDetails}
            className="detail-btn"
          >
            üìä ËØ¶ÁªÜ‰ø°ÊÅØ
          </NutButton>
          
          {showChart && (
            <>
              <NutButton
                type="default"
                onClick={() => showChart('power')}
                className="chart-btn"
              >
                üìà ÂäüÁéáÂõæË°®
              </NutButton>
              
              <NutButton
                type="default"
                onClick={() => showChart('energy')}
                className="chart-btn"
              >
                üìä ÁîµÈáèÂõæË°®
              </NutButton>
            </>
          )}
        </View>
      )}

      {/* ÊéßÂà∂ÊåâÈíÆ */}
      {showControls && (data.status === 'charging' || data.status === 'suspended') && (
        <View className="control-buttons">
          {data.status === 'charging' && (
            <NutButton
              type="warning"
              onClick={handlePauseResume}
              className="pause-btn"
            >
              ‚è∏Ô∏è ÊöÇÂÅúÂÖÖÁîµ
            </NutButton>
          )}
          
          {data.status === 'suspended' && (
            <NutButton
              type="success"
              onClick={handlePauseResume}
              className="resume-btn"
            >
              ‚ñ∂Ô∏è ÊÅ¢Â§çÂÖÖÁîµ
            </NutButton>
          )}
          
          <NutButton
            type="danger"
            onClick={handleStopCharging}
            className="stop-btn"
          >
            ‚èπÔ∏è ÂÅúÊ≠¢ÂÖÖÁîµ
          </NutButton>
        </View>
      )}

      {/* ÂÅúÊ≠¢ÂÖÖÁîµÁ°ÆËÆ§ÂØπËØùÊ°Ü */}
      <Dialog
        visible={state.showStopDialog}
        title="Á°ÆËÆ§ÂÅúÊ≠¢ÂÖÖÁîµ"
        content={`Á°ÆÂÆöË¶ÅÂÅúÊ≠¢ÂÖÖÁîµÂêóÔºü\nÂΩìÂâçÂ∑≤ÂÖÖÁîµ ${data.energyDelivered.toFixed(1)} kWhÔºåË¥πÁî® ¬•${data.currentCost.toFixed(2)}`}
        confirmText="Á°ÆËÆ§ÂÅúÊ≠¢"
        cancelText="ÂèñÊ∂à"
        onConfirm={confirmStopCharging}
        onCancel={() => setState(prev => ({ ...prev, showStopDialog: false }))}
      />

      {/* ËØ¶ÁªÜ‰ø°ÊÅØÂØπËØùÊ°Ü */}
      <Dialog
        visible={state.showDetailsDialog}
        title="ÂÖÖÁîµËØ¶ÁªÜ‰ø°ÊÅØ"
        onClose={() => setState(prev => ({ ...prev, showDetailsDialog: false }))}
        className="details-dialog"
      >
        <View className="details-content">
          <View className="detail-section">
            <Text className="section-title">ÁîµÊ∞îÂèÇÊï∞</Text>
            <View className="detail-items">
              <View className="detail-item">
                <Text className="detail-label">ÁîµÂéã</Text>
                <Text className="detail-value">{data.voltage.toFixed(1)} V</Text>
              </View>
              <View className="detail-item">
                <Text className="detail-label">ÁîµÊµÅ</Text>
                <Text className="detail-value">{data.current.toFixed(1)} A</Text>
              </View>
              <View className="detail-item">
                <Text className="detail-label">Ê∏©Â∫¶</Text>
                <Text className="detail-value">{data.temperature.toFixed(1)} ¬∞C</Text>
              </View>
              <View className="detail-item">
                <Text className="detail-label">ÊúÄÂ§ßÂäüÁéá</Text>
                <Text className="detail-value">{data.maxPower.toFixed(1)} kW</Text>
              </View>
            </View>
          </View>

          <View className="detail-section">
            <Text className="section-title">Ë¥πÁî®‰ø°ÊÅØ</Text>
            <View className="detail-items">
              <View className="detail-item">
                <Text className="detail-label">Áîµ‰ª∑</Text>
                <Text className="detail-value">¬•{data.pricePerKwh.toFixed(2)}/kWh</Text>
              </View>
              <View className="detail-item">
                <Text className="detail-label">ÂΩìÂâçË¥πÁî®</Text>
                <Text className="detail-value">¬•{data.currentCost.toFixed(2)}</Text>
              </View>
              {data.chargingEfficiency && (
                <View className="detail-item">
                  <Text className="detail-label">ÂÖÖÁîµÊïàÁéá</Text>
                  <Text className="detail-value">{data.chargingEfficiency.toFixed(1)}%</Text>
                </View>
              )}
            </View>
          </View>

          {data.batteryLevel && (
            <View className="detail-section">
              <Text className="section-title">ÁîµÊ±†‰ø°ÊÅØ</Text>
              <View className="detail-items">
                <View className="detail-item">
                  <Text className="detail-label">ÁîµÊ±†ÁîµÈáè</Text>
                  <Text className="detail-value">{data.batteryLevel.toFixed(1)}%</Text>
                </View>
                {data.batteryCapacity && (
                  <View className="detail-item">
                    <Text className="detail-label">ÁîµÊ±†ÂÆπÈáè</Text>
                    <Text className="detail-value">{data.batteryCapacity.toFixed(1)} kWh</Text>
                  </View>
                )}
              </View>
            </View>
          )}
        </View>
      </Dialog>

      {/* ÂõæË°®ÂØπËØùÊ°Ü */}
      <Dialog
        visible={state.showChartDialog}
        title={`${state.chartType === 'power' ? 'ÂäüÁéá' : state.chartType === 'energy' ? 'ÁîµÈáè' : 'Ë¥πÁî®'}Ë∂ãÂäøÂõæ`}
        onClose={() => setState(prev => ({ ...prev, showChartDialog: false }))}
        className="chart-dialog"
      >
        <View className="chart-content">
          <Canvas
            ref={canvasRef}
            canvasId="chargingChart"
            style={{ width: '300px', height: '200px' }}
            className="chart-canvas"
          />
          
          <View className="chart-controls">
            <NutButton
              type={state.chartType === 'power' ? 'primary' : 'default'}
              size="mini"
              onClick={() => setState(prev => ({ ...prev, chartType: 'power' }))}
            >
              ÂäüÁéá
            </NutButton>
            <NutButton
              type={state.chartType === 'energy' ? 'primary' : 'default'}
              size="mini"
              onClick={() => setState(prev => ({ ...prev, chartType: 'energy' }))}
            >
              ÁîµÈáè
            </NutButton>
            <NutButton
              type={state.chartType === 'cost' ? 'primary' : 'default'}
              size="mini"
              onClick={() => setState(prev => ({ ...prev, chartType: 'cost' }))}
            >
              Ë¥πÁî®
            </NutButton>
          </View>
        </View>
      </Dialog>
    </View>
  );
};

export default ChargingStatus;